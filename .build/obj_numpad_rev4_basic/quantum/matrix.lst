   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB23:
  14               		.file 1 "../../quantum/matrix.c"
   1:../../quantum/matrix.c **** /*
   2:../../quantum/matrix.c **** Copyright 2012 Jun Wako
   3:../../quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:../../quantum/matrix.c **** 
   5:../../quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:../../quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:../../quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:../../quantum/matrix.c **** (at your option) any later version.
   9:../../quantum/matrix.c **** 
  10:../../quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:../../quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:../../quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:../../quantum/matrix.c **** GNU General Public License for more details.
  14:../../quantum/matrix.c **** 
  15:../../quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:../../quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:../../quantum/matrix.c **** */
  18:../../quantum/matrix.c **** #include <stdint.h>
  19:../../quantum/matrix.c **** #include <stdbool.h>
  20:../../quantum/matrix.c **** #if defined(__AVR__)
  21:../../quantum/matrix.c **** #include <avr/io.h>
  22:../../quantum/matrix.c **** #endif
  23:../../quantum/matrix.c **** #include "wait.h"
  24:../../quantum/matrix.c **** #include "print.h"
  25:../../quantum/matrix.c **** #include "debug.h"
  26:../../quantum/matrix.c **** #include "util.h"
  27:../../quantum/matrix.c **** #include "matrix.h"
  28:../../quantum/matrix.c **** 
  29:../../quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  30:../../quantum/matrix.c **** 
  31:../../quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  32:../../quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  33:../../quantum/matrix.c **** #endif
  34:../../quantum/matrix.c **** static uint8_t debouncing = DEBOUNCING_DELAY;
  35:../../quantum/matrix.c **** 
  36:../../quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  37:../../quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  38:../../quantum/matrix.c **** 
  39:../../quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  40:../../quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  41:../../quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  42:../../quantum/matrix.c **** 
  43:../../quantum/matrix.c **** #if DIODE_DIRECTION == ROW2COL
  44:../../quantum/matrix.c ****     static matrix_row_t matrix_reversed[MATRIX_COLS];
  45:../../quantum/matrix.c ****     static matrix_row_t matrix_reversed_debouncing[MATRIX_COLS];
  46:../../quantum/matrix.c **** #endif
  47:../../quantum/matrix.c **** 
  48:../../quantum/matrix.c **** #if MATRIX_COLS > 16
  49:../../quantum/matrix.c ****     #define SHIFTER 1UL
  50:../../quantum/matrix.c **** #else
  51:../../quantum/matrix.c ****     #define SHIFTER 1
  52:../../quantum/matrix.c **** #endif
  53:../../quantum/matrix.c **** 
  54:../../quantum/matrix.c **** static matrix_row_t read_cols(void);
  55:../../quantum/matrix.c **** static void init_cols(void);
  56:../../quantum/matrix.c **** static void unselect_rows(void);
  57:../../quantum/matrix.c **** static void select_row(uint8_t row);
  58:../../quantum/matrix.c **** 
  59:../../quantum/matrix.c **** __attribute__ ((weak))
  60:../../quantum/matrix.c **** void matrix_init_quantum(void) {
  61:../../quantum/matrix.c ****     matrix_init_kb();
  62:../../quantum/matrix.c **** }
  63:../../quantum/matrix.c **** 
  64:../../quantum/matrix.c **** __attribute__ ((weak))
  65:../../quantum/matrix.c **** void matrix_scan_quantum(void) {
  66:../../quantum/matrix.c ****     matrix_scan_kb();
  67:../../quantum/matrix.c **** }
  68:../../quantum/matrix.c **** 
  69:../../quantum/matrix.c **** __attribute__ ((weak))
  70:../../quantum/matrix.c **** void matrix_init_kb(void) {
  71:../../quantum/matrix.c ****     matrix_init_user();
  72:../../quantum/matrix.c **** }
  73:../../quantum/matrix.c **** 
  74:../../quantum/matrix.c **** __attribute__ ((weak))
  75:../../quantum/matrix.c **** void matrix_scan_kb(void) {
  76:../../quantum/matrix.c ****     matrix_scan_user();
  77:../../quantum/matrix.c **** }
  78:../../quantum/matrix.c **** 
  79:../../quantum/matrix.c **** __attribute__ ((weak))
  80:../../quantum/matrix.c **** void matrix_init_user(void) {
  81:../../quantum/matrix.c **** }
  82:../../quantum/matrix.c **** 
  83:../../quantum/matrix.c **** __attribute__ ((weak))
  84:../../quantum/matrix.c **** void matrix_scan_user(void) {
  85:../../quantum/matrix.c **** }
  86:../../quantum/matrix.c **** 
  87:../../quantum/matrix.c **** inline
  88:../../quantum/matrix.c **** uint8_t matrix_rows(void) {
  89:../../quantum/matrix.c ****     return MATRIX_ROWS;
  90:../../quantum/matrix.c **** }
  91:../../quantum/matrix.c **** 
  92:../../quantum/matrix.c **** inline
  93:../../quantum/matrix.c **** uint8_t matrix_cols(void) {
  94:../../quantum/matrix.c ****     return MATRIX_COLS;
  95:../../quantum/matrix.c **** }
  96:../../quantum/matrix.c **** 
  97:../../quantum/matrix.c **** // void matrix_power_up(void) {
  98:../../quantum/matrix.c **** // #if DIODE_DIRECTION == COL2ROW
  99:../../quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 100:../../quantum/matrix.c **** //         /* DDRxn */
 101:../../quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 102:../../quantum/matrix.c **** //         toggle_row(r);
 103:../../quantum/matrix.c **** //     }
 104:../../quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 105:../../quantum/matrix.c **** //         /* PORTxn */
 106:../../quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 107:../../quantum/matrix.c **** //     }
 108:../../quantum/matrix.c **** // #else
 109:../../quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 110:../../quantum/matrix.c **** //         /* DDRxn */
 111:../../quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 112:../../quantum/matrix.c **** //         toggle_col(c);
 113:../../quantum/matrix.c **** //     }
 114:../../quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 115:../../quantum/matrix.c **** //         /* PORTxn */
 116:../../quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 117:../../quantum/matrix.c **** //     }
 118:../../quantum/matrix.c **** // #endif
 119:../../quantum/matrix.c **** // }
 120:../../quantum/matrix.c **** 
 121:../../quantum/matrix.c **** void matrix_init(void) {
 122:../../quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 123:../../quantum/matrix.c ****     #ifdef __AVR_ATmega32U4__
 124:../../quantum/matrix.c ****         MCUCR |= _BV(JTD);
 125:../../quantum/matrix.c ****         MCUCR |= _BV(JTD);
 126:../../quantum/matrix.c ****     #endif
 127:../../quantum/matrix.c **** 
 128:../../quantum/matrix.c ****     // initialize row and col
 129:../../quantum/matrix.c ****     unselect_rows();
 130:../../quantum/matrix.c ****     init_cols();
 131:../../quantum/matrix.c **** 
 132:../../quantum/matrix.c ****     // initialize matrix state: all keys off
 133:../../quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 134:../../quantum/matrix.c ****         matrix[i] = 0;
 135:../../quantum/matrix.c ****         matrix_debouncing[i] = 0;
 136:../../quantum/matrix.c ****     }
 137:../../quantum/matrix.c **** 
 138:../../quantum/matrix.c ****     matrix_init_quantum();
 139:../../quantum/matrix.c **** }
 140:../../quantum/matrix.c **** 
 141:../../quantum/matrix.c **** uint8_t matrix_scan(void)
 142:../../quantum/matrix.c **** {
 143:../../quantum/matrix.c **** 
 144:../../quantum/matrix.c **** #if DIODE_DIRECTION == COL2ROW
 145:../../quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 146:../../quantum/matrix.c ****         select_row(i);
 147:../../quantum/matrix.c ****         wait_us(30);  // without this wait read unstable value.
 148:../../quantum/matrix.c ****         matrix_row_t cols = read_cols();
 149:../../quantum/matrix.c ****         if (matrix_debouncing[i] != cols) {
 150:../../quantum/matrix.c ****             matrix_debouncing[i] = cols;
 151:../../quantum/matrix.c ****             if (debouncing) {
 152:../../quantum/matrix.c ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 153:../../quantum/matrix.c ****             }
 154:../../quantum/matrix.c ****             debouncing = DEBOUNCING_DELAY;
 155:../../quantum/matrix.c ****         }
 156:../../quantum/matrix.c ****         unselect_rows();
 157:../../quantum/matrix.c ****     }
 158:../../quantum/matrix.c **** 
 159:../../quantum/matrix.c ****     if (debouncing) {
 160:../../quantum/matrix.c ****         if (--debouncing) {
 161:../../quantum/matrix.c ****             wait_ms(1);
 162:../../quantum/matrix.c ****         } else {
 163:../../quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 164:../../quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 165:../../quantum/matrix.c ****             }
 166:../../quantum/matrix.c ****         }
 167:../../quantum/matrix.c ****     }
 168:../../quantum/matrix.c **** #else
 169:../../quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_COLS; i++) {
 170:../../quantum/matrix.c ****         select_row(i);
 171:../../quantum/matrix.c ****         wait_us(30);  // without this wait read unstable value.
 172:../../quantum/matrix.c ****         matrix_row_t rows = read_cols();
 173:../../quantum/matrix.c ****         if (matrix_reversed_debouncing[i] != rows) {
 174:../../quantum/matrix.c ****             matrix_reversed_debouncing[i] = rows;
 175:../../quantum/matrix.c ****             if (debouncing) {
 176:../../quantum/matrix.c ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 177:../../quantum/matrix.c ****             }
 178:../../quantum/matrix.c ****             debouncing = DEBOUNCING_DELAY;
 179:../../quantum/matrix.c ****         }
 180:../../quantum/matrix.c ****         unselect_rows();
 181:../../quantum/matrix.c ****     }
 182:../../quantum/matrix.c **** 
 183:../../quantum/matrix.c ****     if (debouncing) {
 184:../../quantum/matrix.c ****         if (--debouncing) {
 185:../../quantum/matrix.c ****             wait_ms(1);
 186:../../quantum/matrix.c ****         } else {
 187:../../quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_COLS; i++) {
 188:../../quantum/matrix.c ****                 matrix_reversed[i] = matrix_reversed_debouncing[i];
 189:../../quantum/matrix.c ****             }
 190:../../quantum/matrix.c ****         }
 191:../../quantum/matrix.c ****     }
 192:../../quantum/matrix.c ****     for (uint8_t y = 0; y < MATRIX_ROWS; y++) {
 193:../../quantum/matrix.c ****         matrix_row_t row = 0;
 194:../../quantum/matrix.c ****         for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 195:../../quantum/matrix.c ****             row |= ((matrix_reversed[x] & (1<<y)) >> y) << x;
 196:../../quantum/matrix.c ****         }
 197:../../quantum/matrix.c ****         matrix[y] = row;
 198:../../quantum/matrix.c ****     }
 199:../../quantum/matrix.c **** #endif
 200:../../quantum/matrix.c **** 
 201:../../quantum/matrix.c ****     matrix_scan_quantum();
 202:../../quantum/matrix.c **** 
 203:../../quantum/matrix.c ****     return 1;
 204:../../quantum/matrix.c **** }
 205:../../quantum/matrix.c **** 
 206:../../quantum/matrix.c **** bool matrix_is_modified(void)
 207:../../quantum/matrix.c **** {
 208:../../quantum/matrix.c ****     if (debouncing) return false;
 209:../../quantum/matrix.c ****     return true;
 210:../../quantum/matrix.c **** }
 211:../../quantum/matrix.c **** 
 212:../../quantum/matrix.c **** inline
 213:../../quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 214:../../quantum/matrix.c **** {
 215:../../quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 216:../../quantum/matrix.c **** }
 217:../../quantum/matrix.c **** 
 218:../../quantum/matrix.c **** inline
 219:../../quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 220:../../quantum/matrix.c **** {
 221:../../quantum/matrix.c ****     return matrix[row];
 222:../../quantum/matrix.c **** }
 223:../../quantum/matrix.c **** 
 224:../../quantum/matrix.c **** void matrix_print(void)
 225:../../quantum/matrix.c **** {
 226:../../quantum/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 227:../../quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 228:../../quantum/matrix.c ****         phex(row); print(": ");
 229:../../quantum/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 230:../../quantum/matrix.c ****         print("\n");
 231:../../quantum/matrix.c ****     }
 232:../../quantum/matrix.c **** }
 233:../../quantum/matrix.c **** 
 234:../../quantum/matrix.c **** uint8_t matrix_key_count(void)
 235:../../quantum/matrix.c **** {
 236:../../quantum/matrix.c ****     uint8_t count = 0;
 237:../../quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 238:../../quantum/matrix.c ****         count += bitpop16(matrix[i]);
 239:../../quantum/matrix.c ****     }
 240:../../quantum/matrix.c ****     return count;
 241:../../quantum/matrix.c **** }
 242:../../quantum/matrix.c **** 
 243:../../quantum/matrix.c **** static void init_cols(void)
 244:../../quantum/matrix.c **** {
 245:../../quantum/matrix.c **** #if DIODE_DIRECTION == COL2ROW
 246:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 247:../../quantum/matrix.c ****         int pin = col_pins[x];
 248:../../quantum/matrix.c **** #else
 249:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_ROWS; x++) {
 250:../../quantum/matrix.c ****         int pin = row_pins[x];
 251:../../quantum/matrix.c **** #endif
 252:../../quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &=  ~_BV(pin & 0xF);
 253:../../quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |= _BV(pin & 0xF);
 254:../../quantum/matrix.c ****     }
 255:../../quantum/matrix.c **** }
 256:../../quantum/matrix.c **** 
 257:../../quantum/matrix.c **** static matrix_row_t read_cols(void)
 258:../../quantum/matrix.c **** {
 259:../../quantum/matrix.c ****     matrix_row_t result = 0;
 260:../../quantum/matrix.c **** 
 261:../../quantum/matrix.c **** #if DIODE_DIRECTION == COL2ROW
 262:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {     
 263:../../quantum/matrix.c ****         int pin = col_pins[x];
 264:../../quantum/matrix.c **** #else
 265:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_ROWS; x++) {
 266:../../quantum/matrix.c ****         int pin = row_pins[x];
 267:../../quantum/matrix.c **** #endif
 268:../../quantum/matrix.c ****         result |= (_SFR_IO8(pin >> 4) & _BV(pin & 0xF)) ? 0 : (SHIFTER << x);
 269:../../quantum/matrix.c ****     }
 270:../../quantum/matrix.c ****     return result;
 271:../../quantum/matrix.c **** }
 272:../../quantum/matrix.c **** 
 273:../../quantum/matrix.c **** static void unselect_rows(void)
 274:../../quantum/matrix.c **** {
  15               		.loc 1 274 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22 0000 A0E0      		ldi r26,lo8(row_pins)
  23 0002 B0E0      		ldi r27,hi8(row_pins)
  24               	.LBB9:
  25               	.LBB10:
 275:../../quantum/matrix.c **** #if DIODE_DIRECTION == COL2ROW
 276:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_ROWS; x++) { 
 277:../../quantum/matrix.c ****         int pin = row_pins[x];
 278:../../quantum/matrix.c **** #else
 279:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) { 
 280:../../quantum/matrix.c ****         int pin = col_pins[x];
 281:../../quantum/matrix.c **** #endif
 282:../../quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &=  ~_BV(pin & 0xF);
  26               		.loc 1 282 0
  27 0004 21E0      		ldi r18,lo8(1)
  28 0006 30E0      		ldi r19,0
  29               	.LVL1:
  30               	.L3:
 277:../../quantum/matrix.c ****         int pin = row_pins[x];
  31               		.loc 1 277 0 discriminator 2
  32 0008 8D91      		ld r24,X+
  33               	.LVL2:
  34 000a E82F      		mov r30,r24
  35 000c F0E0      		ldi r31,0
  36               		.loc 1 282 0 discriminator 2
  37 000e 94E0      		ldi r25,4
  38               		1:
  39 0010 F595      		asr r31
  40 0012 E795      		ror r30
  41 0014 9A95      		dec r25
  42 0016 01F4      		brne 1b
  43 0018 41A1      		ldd r20,Z+33
  44 001a 8F70      		andi r24,lo8(15)
  45               	.LVL3:
  46 001c B901      		movw r22,r18
  47 001e 00C0      		rjmp 2f
  48               		1:
  49 0020 660F      		lsl r22
  50 0022 771F      		rol r23
  51               		2:
  52 0024 8A95      		dec r24
  53 0026 02F4      		brpl 1b
  54 0028 CB01      		movw r24,r22
  55 002a 962F      		mov r25,r22
  56 002c 9095      		com r25
  57 002e 4923      		and r20,r25
  58 0030 41A3      		std Z+33,r20
  59               	.LVL4:
 283:../../quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |= _BV(pin & 0xF);
  60               		.loc 1 283 0 discriminator 2
  61 0032 92A1      		ldd r25,Z+34
  62 0034 982B      		or r25,r24
  63 0036 92A3      		std Z+34,r25
  64               	.LVL5:
  65               	.LBE10:
 276:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_ROWS; x++) { 
  66               		.loc 1 276 0 discriminator 2
  67 0038 70E0      		ldi r23,hi8(row_pins+5)
  68 003a A030      		cpi r26,lo8(row_pins+5)
  69 003c B707      		cpc r27,r23
  70 003e 01F4      		brne .L3
  71               	/* epilogue start */
  72               	.LBE9:
 284:../../quantum/matrix.c ****     }
 285:../../quantum/matrix.c **** }
  73               		.loc 1 285 0
  74 0040 0895      		ret
  75               		.cfi_endproc
  76               	.LFE23:
  78               		.section	.text.matrix_init_user,"ax",@progbits
  79               		.weak	matrix_init_user
  81               	matrix_init_user:
  82               	.LFB10:
  80:../../quantum/matrix.c **** void matrix_init_user(void) {
  83               		.loc 1 80 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
  89 0000 0895      		ret
  90               		.cfi_endproc
  91               	.LFE10:
  93               		.section	.text.matrix_init_kb,"ax",@progbits
  94               		.weak	matrix_init_kb
  96               	matrix_init_kb:
  97               	.LFB8:
  70:../../quantum/matrix.c **** void matrix_init_kb(void) {
  98               		.loc 1 70 0
  99               		.cfi_startproc
 100               	/* prologue: function */
 101               	/* frame size = 0 */
 102               	/* stack size = 0 */
 103               	.L__stack_usage = 0
  71:../../quantum/matrix.c ****     matrix_init_user();
 104               		.loc 1 71 0
 105 0000 0C94 0000 		jmp matrix_init_user
 106               	.LVL6:
 107               		.cfi_endproc
 108               	.LFE8:
 110               		.section	.text.matrix_init_quantum,"ax",@progbits
 111               		.weak	matrix_init_quantum
 113               	matrix_init_quantum:
 114               	.LFB6:
  60:../../quantum/matrix.c **** void matrix_init_quantum(void) {
 115               		.loc 1 60 0
 116               		.cfi_startproc
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
  61:../../quantum/matrix.c ****     matrix_init_kb();
 121               		.loc 1 61 0
 122 0000 0C94 0000 		jmp matrix_init_kb
 123               	.LVL7:
 124               		.cfi_endproc
 125               	.LFE6:
 127               		.section	.text.matrix_scan_user,"ax",@progbits
 128               		.weak	matrix_scan_user
 130               	matrix_scan_user:
 131               	.LFB11:
  84:../../quantum/matrix.c **** void matrix_scan_user(void) {
 132               		.loc 1 84 0
 133               		.cfi_startproc
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 138 0000 0895      		ret
 139               		.cfi_endproc
 140               	.LFE11:
 142               		.section	.text.matrix_scan_kb,"ax",@progbits
 143               		.weak	matrix_scan_kb
 145               	matrix_scan_kb:
 146               	.LFB9:
  75:../../quantum/matrix.c **** void matrix_scan_kb(void) {
 147               		.loc 1 75 0
 148               		.cfi_startproc
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151               	/* stack size = 0 */
 152               	.L__stack_usage = 0
  76:../../quantum/matrix.c ****     matrix_scan_user();
 153               		.loc 1 76 0
 154 0000 0C94 0000 		jmp matrix_scan_user
 155               	.LVL8:
 156               		.cfi_endproc
 157               	.LFE9:
 159               		.section	.text.matrix_scan_quantum,"ax",@progbits
 160               		.weak	matrix_scan_quantum
 162               	matrix_scan_quantum:
 163               	.LFB7:
  65:../../quantum/matrix.c **** void matrix_scan_quantum(void) {
 164               		.loc 1 65 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
  66:../../quantum/matrix.c ****     matrix_scan_kb();
 170               		.loc 1 66 0
 171 0000 0C94 0000 		jmp matrix_scan_kb
 172               	.LVL9:
 173               		.cfi_endproc
 174               	.LFE7:
 176               		.section	.text.matrix_rows,"ax",@progbits
 177               	.global	matrix_rows
 179               	matrix_rows:
 180               	.LFB12:
  88:../../quantum/matrix.c **** uint8_t matrix_rows(void) {
 181               		.loc 1 88 0
 182               		.cfi_startproc
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
  90:../../quantum/matrix.c **** }
 187               		.loc 1 90 0
 188 0000 85E0      		ldi r24,lo8(5)
 189 0002 0895      		ret
 190               		.cfi_endproc
 191               	.LFE12:
 193               		.section	.text.matrix_cols,"ax",@progbits
 194               	.global	matrix_cols
 196               	matrix_cols:
 197               	.LFB13:
  93:../../quantum/matrix.c **** uint8_t matrix_cols(void) {
 198               		.loc 1 93 0
 199               		.cfi_startproc
 200               	/* prologue: function */
 201               	/* frame size = 0 */
 202               	/* stack size = 0 */
 203               	.L__stack_usage = 0
  95:../../quantum/matrix.c **** }
 204               		.loc 1 95 0
 205 0000 84E0      		ldi r24,lo8(4)
 206 0002 0895      		ret
 207               		.cfi_endproc
 208               	.LFE13:
 210               		.section	.text.matrix_init,"ax",@progbits
 211               	.global	matrix_init
 213               	matrix_init:
 214               	.LFB14:
 121:../../quantum/matrix.c **** void matrix_init(void) {
 215               		.loc 1 121 0
 216               		.cfi_startproc
 217               	/* prologue: function */
 218               	/* frame size = 0 */
 219               	/* stack size = 0 */
 220               	.L__stack_usage = 0
 124:../../quantum/matrix.c ****         MCUCR |= _BV(JTD);
 221               		.loc 1 124 0
 222 0000 85B7      		in r24,0x35
 223 0002 8068      		ori r24,lo8(-128)
 224 0004 85BF      		out 0x35,r24
 125:../../quantum/matrix.c ****         MCUCR |= _BV(JTD);
 225               		.loc 1 125 0
 226 0006 85B7      		in r24,0x35
 227 0008 8068      		ori r24,lo8(-128)
 228 000a 85BF      		out 0x35,r24
 129:../../quantum/matrix.c ****     unselect_rows();
 229               		.loc 1 129 0
 230 000c 0E94 0000 		call unselect_rows
 231               	.LVL10:
 232 0010 A0E0      		ldi r26,lo8(col_pins)
 233 0012 B0E0      		ldi r27,hi8(col_pins)
 234               	.LBB16:
 235               	.LBB17:
 236               	.LBB18:
 252:../../quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &=  ~_BV(pin & 0xF);
 237               		.loc 1 252 0
 238 0014 21E0      		ldi r18,lo8(1)
 239 0016 30E0      		ldi r19,0
 240               	.LVL11:
 241               	.L15:
 247:../../quantum/matrix.c ****         int pin = col_pins[x];
 242               		.loc 1 247 0
 243 0018 8D91      		ld r24,X+
 244               	.LVL12:
 245 001a E82F      		mov r30,r24
 246 001c F0E0      		ldi r31,0
 252:../../quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &=  ~_BV(pin & 0xF);
 247               		.loc 1 252 0
 248 001e 44E0      		ldi r20,4
 249               		1:
 250 0020 F595      		asr r31
 251 0022 E795      		ror r30
 252 0024 4A95      		dec r20
 253 0026 01F4      		brne 1b
 254 0028 41A1      		ldd r20,Z+33
 255 002a 8F70      		andi r24,lo8(15)
 256               	.LVL13:
 257 002c B901      		movw r22,r18
 258 002e 00C0      		rjmp 2f
 259               		1:
 260 0030 660F      		lsl r22
 261 0032 771F      		rol r23
 262               		2:
 263 0034 8A95      		dec r24
 264 0036 02F4      		brpl 1b
 265 0038 CB01      		movw r24,r22
 266 003a 962F      		mov r25,r22
 267 003c 9095      		com r25
 268 003e 4923      		and r20,r25
 269 0040 41A3      		std Z+33,r20
 270               	.LVL14:
 253:../../quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |= _BV(pin & 0xF);
 271               		.loc 1 253 0
 272 0042 92A1      		ldd r25,Z+34
 273 0044 982B      		or r25,r24
 274 0046 92A3      		std Z+34,r25
 275               	.LVL15:
 276               	.LBE18:
 246:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {
 277               		.loc 1 246 0
 278 0048 70E0      		ldi r23,hi8(col_pins+4)
 279 004a A030      		cpi r26,lo8(col_pins+4)
 280 004c B707      		cpc r27,r23
 281 004e 01F4      		brne .L15
 282 0050 E0E0      		ldi r30,lo8(matrix)
 283 0052 F0E0      		ldi r31,hi8(matrix)
 284 0054 A0E0      		ldi r26,lo8(matrix_debouncing)
 285 0056 B0E0      		ldi r27,hi8(matrix_debouncing)
 286               	.LVL16:
 287               	.L17:
 288               	.LBE17:
 289               	.LBE16:
 290               	.LBB19:
 134:../../quantum/matrix.c ****         matrix[i] = 0;
 291               		.loc 1 134 0 discriminator 2
 292 0058 1192      		st Z+,__zero_reg__
 293               	.LVL17:
 135:../../quantum/matrix.c ****         matrix_debouncing[i] = 0;
 294               		.loc 1 135 0 discriminator 2
 295 005a 1D92      		st X+,__zero_reg__
 296               	.LVL18:
 133:../../quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 297               		.loc 1 133 0 discriminator 2
 298 005c 80E0      		ldi r24,hi8(matrix+5)
 299 005e E030      		cpi r30,lo8(matrix+5)
 300 0060 F807      		cpc r31,r24
 301 0062 01F4      		brne .L17
 302               	.LBE19:
 138:../../quantum/matrix.c ****     matrix_init_quantum();
 303               		.loc 1 138 0
 304 0064 0C94 0000 		jmp matrix_init_quantum
 305               	.LVL19:
 306               		.cfi_endproc
 307               	.LFE14:
 309               		.section	.text.matrix_scan,"ax",@progbits
 310               	.global	matrix_scan
 312               	matrix_scan:
 313               	.LFB15:
 142:../../quantum/matrix.c **** {
 314               		.loc 1 142 0
 315               		.cfi_startproc
 316 0000 DF92      		push r13
 317               	.LCFI0:
 318               		.cfi_def_cfa_offset 3
 319               		.cfi_offset 13, -2
 320 0002 EF92      		push r14
 321               	.LCFI1:
 322               		.cfi_def_cfa_offset 4
 323               		.cfi_offset 14, -3
 324 0004 FF92      		push r15
 325               	.LCFI2:
 326               		.cfi_def_cfa_offset 5
 327               		.cfi_offset 15, -4
 328 0006 0F93      		push r16
 329               	.LCFI3:
 330               		.cfi_def_cfa_offset 6
 331               		.cfi_offset 16, -5
 332 0008 1F93      		push r17
 333               	.LCFI4:
 334               		.cfi_def_cfa_offset 7
 335               		.cfi_offset 17, -6
 336 000a CF93      		push r28
 337               	.LCFI5:
 338               		.cfi_def_cfa_offset 8
 339               		.cfi_offset 28, -7
 340 000c DF93      		push r29
 341               	.LCFI6:
 342               		.cfi_def_cfa_offset 9
 343               		.cfi_offset 29, -8
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 346               	/* stack size = 7 */
 347               	.L__stack_usage = 7
 348               	.LVL20:
 349 000e 00E0      		ldi r16,lo8(row_pins)
 350 0010 10E0      		ldi r17,hi8(row_pins)
 142:../../quantum/matrix.c **** {
 351               		.loc 1 142 0
 352 0012 C0E0      		ldi r28,lo8(matrix_debouncing)
 353 0014 D0E0      		ldi r29,hi8(matrix_debouncing)
 354               	.LBB33:
 355               	.LBB34:
 356               	.LBB35:
 357               	.LBB36:
 286:../../quantum/matrix.c **** 
 287:../../quantum/matrix.c **** static void select_row(uint8_t row)
 288:../../quantum/matrix.c **** {
 289:../../quantum/matrix.c **** 
 290:../../quantum/matrix.c **** #if DIODE_DIRECTION == COL2ROW
 291:../../quantum/matrix.c ****     int pin = row_pins[row];
 292:../../quantum/matrix.c **** #else
 293:../../quantum/matrix.c ****     int pin = col_pins[row];
 294:../../quantum/matrix.c **** #endif
 295:../../quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF);
 358               		.loc 1 295 0
 359 0016 EE24      		clr r14
 360 0018 E394      		inc r14
 361 001a F12C      		mov r15,__zero_reg__
 362               	.LBE36:
 363               	.LBE35:
 154:../../quantum/matrix.c ****             debouncing = DEBOUNCING_DELAY;
 364               		.loc 1 154 0
 365 001c F5E0      		ldi r31,lo8(5)
 366 001e DF2E      		mov r13,r31
 367               	.LVL21:
 368               	.L24:
 369               	.LBB38:
 370               	.LBB37:
 291:../../quantum/matrix.c ****     int pin = row_pins[row];
 371               		.loc 1 291 0
 372 0020 F801      		movw r30,r16
 373 0022 8191      		ld r24,Z+
 374 0024 8F01      		movw r16,r30
 375               	.LVL22:
 376 0026 E82F      		mov r30,r24
 377 0028 F0E0      		ldi r31,0
 378               		.loc 1 295 0
 379 002a 74E0      		ldi r23,4
 380               		1:
 381 002c F595      		asr r31
 382 002e E795      		ror r30
 383 0030 7A95      		dec r23
 384 0032 01F4      		brne 1b
 385 0034 21A1      		ldd r18,Z+33
 386 0036 8F70      		andi r24,lo8(15)
 387               	.LVL23:
 388 0038 A701      		movw r20,r14
 389 003a 00C0      		rjmp 2f
 390               		1:
 391 003c 440F      		lsl r20
 392 003e 551F      		rol r21
 393               		2:
 394 0040 8A95      		dec r24
 395 0042 02F4      		brpl 1b
 396 0044 CA01      		movw r24,r20
 397 0046 242B      		or r18,r20
 398 0048 21A3      		std Z+33,r18
 399               	.LVL24:
 296:../../quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF);
 400               		.loc 1 296 0
 401 004a 92A1      		ldd r25,Z+34
 402 004c 8095      		com r24
 403 004e 9823      		and r25,r24
 404 0050 92A3      		std Z+34,r25
 405               	.LVL25:
 406               	.LBE37:
 407               	.LBE38:
 408               	.LBB39:
 409               	.LBB40:
 410               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 411               		.loc 2 246 0
 412 0052 50EA      		ldi r21,lo8(-96)
 413 0054 5A95      		1: dec r21
 414 0056 01F4      		brne 1b
 415               	.LVL26:
 416 0058 A0E0      		ldi r26,lo8(col_pins)
 417 005a B0E0      		ldi r27,hi8(col_pins)
 418               	.LBE40:
 419               	.LBE39:
 420               	.LBB41:
 421               	.LBB42:
 259:../../quantum/matrix.c ****     matrix_row_t result = 0;
 422               		.loc 1 259 0
 423 005c 40E0      		ldi r20,0
 424               	.LBB43:
 262:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {     
 425               		.loc 1 262 0
 426 005e 80E0      		ldi r24,0
 427 0060 90E0      		ldi r25,0
 428               	.LVL27:
 429               	.L21:
 430               	.LBB44:
 263:../../quantum/matrix.c ****         int pin = col_pins[x];
 431               		.loc 1 263 0
 432 0062 5D91      		ld r21,X+
 433               	.LVL28:
 434 0064 E52F      		mov r30,r21
 435 0066 F0E0      		ldi r31,0
 268:../../quantum/matrix.c ****         result |= (_SFR_IO8(pin >> 4) & _BV(pin & 0xF)) ? 0 : (SHIFTER << x);
 436               		.loc 1 268 0
 437 0068 64E0      		ldi r22,4
 438               		1:
 439 006a F595      		asr r31
 440 006c E795      		ror r30
 441 006e 6A95      		dec r22
 442 0070 01F4      		brne 1b
 443 0072 20A1      		ldd r18,Z+32
 444 0074 30E0      		ldi r19,0
 445 0076 5F70      		andi r21,lo8(15)
 446               	.LVL29:
 447 0078 00C0      		rjmp 2f
 448               		1:
 449 007a 3595      		asr r19
 450 007c 2795      		ror r18
 451               		2:
 452 007e 5A95      		dec r21
 453 0080 02F4      		brpl 1b
 454 0082 20FD      		sbrc r18,0
 455 0084 00C0      		rjmp .L30
 456 0086 2E2D      		mov r18,r14
 457 0088 082E      		mov r0,r24
 458 008a 00C0      		rjmp 2f
 459               		1:
 460 008c 220F      		lsl r18
 461               		2:
 462 008e 0A94      		dec r0
 463 0090 02F4      		brpl 1b
 464 0092 00C0      		rjmp .L19
 465               	.L30:
 466 0094 20E0      		ldi r18,0
 467               	.L19:
 468 0096 422B      		or r20,r18
 469               	.LVL30:
 470               	.LBE44:
 262:../../quantum/matrix.c ****     for(int x = 0; x < MATRIX_COLS; x++) {     
 471               		.loc 1 262 0
 472 0098 0196      		adiw r24,1
 473               	.LVL31:
 474 009a 8430      		cpi r24,4
 475 009c 9105      		cpc r25,__zero_reg__
 476 009e 01F4      		brne .L21
 477               	.LBE43:
 478               	.LBE42:
 479               	.LBE41:
 149:../../quantum/matrix.c ****         if (matrix_debouncing[i] != cols) {
 480               		.loc 1 149 0
 481 00a0 8881      		ld r24,Y
 482               	.LVL32:
 483 00a2 8417      		cp r24,r20
 484 00a4 01F0      		breq .L22
 150:../../quantum/matrix.c ****             matrix_debouncing[i] = cols;
 485               		.loc 1 150 0
 486 00a6 4883      		st Y,r20
 154:../../quantum/matrix.c ****             debouncing = DEBOUNCING_DELAY;
 487               		.loc 1 154 0
 488 00a8 D092 0000 		sts debouncing,r13
 489               	.L22:
 156:../../quantum/matrix.c ****         unselect_rows();
 490               		.loc 1 156 0
 491 00ac 0E94 0000 		call unselect_rows
 492               	.LVL33:
 493 00b0 2196      		adiw r28,1
 494               	.LBE34:
 145:../../quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 495               		.loc 1 145 0
 496 00b2 80E0      		ldi r24,hi8(row_pins+5)
 497 00b4 0030      		cpi r16,lo8(row_pins+5)
 498 00b6 1807      		cpc r17,r24
 499 00b8 01F0      		breq .+2
 500 00ba 00C0      		rjmp .L24
 501               	.LBE33:
 159:../../quantum/matrix.c ****     if (debouncing) {
 502               		.loc 1 159 0
 503 00bc 8091 0000 		lds r24,debouncing
 504 00c0 8823      		tst r24
 505 00c2 01F0      		breq .L26
 160:../../quantum/matrix.c ****         if (--debouncing) {
 506               		.loc 1 160 0
 507 00c4 8150      		subi r24,lo8(-(-1))
 508 00c6 8093 0000 		sts debouncing,r24
 509 00ca 8823      		tst r24
 510 00cc 01F0      		breq .L27
 511               	.LVL34:
 512               	.LBB45:
 513               	.LBB46:
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 514               		.loc 2 164 0
 515 00ce EFE9      		ldi r30,lo8(3999)
 516 00d0 FFE0      		ldi r31,hi8(3999)
 517 00d2 3197      		1: sbiw r30,1
 518 00d4 01F4      		brne 1b
 519 00d6 00C0      		rjmp .
 520 00d8 0000      		nop
 521 00da 00C0      		rjmp .L26
 522               	.LVL35:
 523               	.L27:
 524 00dc A0E0      		ldi r26,lo8(matrix)
 525 00de B0E0      		ldi r27,hi8(matrix)
 526               	.LBE46:
 527               	.LBE45:
 160:../../quantum/matrix.c ****         if (--debouncing) {
 528               		.loc 1 160 0
 529 00e0 E0E0      		ldi r30,lo8(matrix_debouncing)
 530 00e2 F0E0      		ldi r31,hi8(matrix_debouncing)
 531               	.L29:
 532               	.LVL36:
 533               	.LBB47:
 164:../../quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 534               		.loc 1 164 0 discriminator 2
 535 00e4 8191      		ld r24,Z+
 536               	.LVL37:
 537 00e6 8D93      		st X+,r24
 538               	.LVL38:
 163:../../quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 539               		.loc 1 163 0 discriminator 2
 540 00e8 40E0      		ldi r20,hi8(matrix_debouncing+5)
 541 00ea E030      		cpi r30,lo8(matrix_debouncing+5)
 542 00ec F407      		cpc r31,r20
 543 00ee 01F4      		brne .L29
 544               	.LVL39:
 545               	.L26:
 546               	.LBE47:
 201:../../quantum/matrix.c ****     matrix_scan_quantum();
 547               		.loc 1 201 0
 548 00f0 0E94 0000 		call matrix_scan_quantum
 549               	.LVL40:
 204:../../quantum/matrix.c **** }
 550               		.loc 1 204 0
 551 00f4 81E0      		ldi r24,lo8(1)
 552               	/* epilogue start */
 553 00f6 DF91      		pop r29
 554 00f8 CF91      		pop r28
 555 00fa 1F91      		pop r17
 556 00fc 0F91      		pop r16
 557               	.LVL41:
 558 00fe FF90      		pop r15
 559 0100 EF90      		pop r14
 560 0102 DF90      		pop r13
 561 0104 0895      		ret
 562               		.cfi_endproc
 563               	.LFE15:
 565               		.section	.text.matrix_is_modified,"ax",@progbits
 566               	.global	matrix_is_modified
 568               	matrix_is_modified:
 569               	.LFB16:
 207:../../quantum/matrix.c **** {
 570               		.loc 1 207 0
 571               		.cfi_startproc
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 0 */
 575               	.L__stack_usage = 0
 208:../../quantum/matrix.c ****     if (debouncing) return false;
 576               		.loc 1 208 0
 577 0000 81E0      		ldi r24,lo8(1)
 578 0002 9091 0000 		lds r25,debouncing
 579 0006 9111      		cpse r25,__zero_reg__
 580 0008 80E0      		ldi r24,0
 581               	.L34:
 210:../../quantum/matrix.c **** }
 582               		.loc 1 210 0
 583 000a 0895      		ret
 584               		.cfi_endproc
 585               	.LFE16:
 587               		.section	.text.matrix_is_on,"ax",@progbits
 588               	.global	matrix_is_on
 590               	matrix_is_on:
 591               	.LFB17:
 214:../../quantum/matrix.c **** {
 592               		.loc 1 214 0
 593               		.cfi_startproc
 594               	.LVL42:
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 215:../../quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 599               		.loc 1 215 0
 600 0000 E82F      		mov r30,r24
 601 0002 F0E0      		ldi r31,0
 602 0004 E050      		subi r30,lo8(-(matrix))
 603 0006 F040      		sbci r31,hi8(-(matrix))
 604 0008 2081      		ld r18,Z
 605 000a 30E0      		ldi r19,0
 606 000c 81E0      		ldi r24,lo8(1)
 607 000e 90E0      		ldi r25,0
 608               	.LVL43:
 609 0010 6230      		cpi r22,lo8(2)
 610 0012 00F4      		brsh .L39
 611 0014 80E0      		ldi r24,0
 612 0016 90E0      		ldi r25,0
 613               	.L39:
 614 0018 8223      		and r24,r18
 615 001a 9323      		and r25,r19
 216:../../quantum/matrix.c **** }
 616               		.loc 1 216 0
 617 001c 8170      		andi r24,lo8(1)
 618 001e 0895      		ret
 619               		.cfi_endproc
 620               	.LFE17:
 622               		.section	.text.matrix_get_row,"ax",@progbits
 623               	.global	matrix_get_row
 625               	matrix_get_row:
 626               	.LFB18:
 220:../../quantum/matrix.c **** {
 627               		.loc 1 220 0
 628               		.cfi_startproc
 629               	.LVL44:
 630               	/* prologue: function */
 631               	/* frame size = 0 */
 632               	/* stack size = 0 */
 633               	.L__stack_usage = 0
 221:../../quantum/matrix.c ****     return matrix[row];
 634               		.loc 1 221 0
 635 0000 E82F      		mov r30,r24
 636 0002 F0E0      		ldi r31,0
 637 0004 E050      		subi r30,lo8(-(matrix))
 638 0006 F040      		sbci r31,hi8(-(matrix))
 222:../../quantum/matrix.c **** }
 639               		.loc 1 222 0
 640 0008 8081      		ld r24,Z
 641               	.LVL45:
 642 000a 0895      		ret
 643               		.cfi_endproc
 644               	.LFE18:
 646               		.section	.text.matrix_print,"ax",@progbits
 647               	.global	matrix_print
 649               	matrix_print:
 650               	.LFB19:
 225:../../quantum/matrix.c **** {
 651               		.loc 1 225 0
 652               		.cfi_startproc
 653               	/* prologue: function */
 654               	/* frame size = 0 */
 655               	/* stack size = 0 */
 656               	.L__stack_usage = 0
 657               	.LVL46:
 658 0000 0895      		ret
 659               		.cfi_endproc
 660               	.LFE19:
 662               		.section	.text.matrix_key_count,"ax",@progbits
 663               	.global	matrix_key_count
 665               	matrix_key_count:
 666               	.LFB20:
 235:../../quantum/matrix.c **** {
 667               		.loc 1 235 0
 668               		.cfi_startproc
 235:../../quantum/matrix.c **** {
 669               		.loc 1 235 0
 670 0000 1F93      		push r17
 671               	.LCFI7:
 672               		.cfi_def_cfa_offset 3
 673               		.cfi_offset 17, -2
 674 0002 CF93      		push r28
 675               	.LCFI8:
 676               		.cfi_def_cfa_offset 4
 677               		.cfi_offset 28, -3
 678 0004 DF93      		push r29
 679               	.LCFI9:
 680               		.cfi_def_cfa_offset 5
 681               		.cfi_offset 29, -4
 682               	/* prologue: function */
 683               	/* frame size = 0 */
 684               	/* stack size = 3 */
 685               	.L__stack_usage = 3
 686               	.LVL47:
 687 0006 C0E0      		ldi r28,lo8(matrix)
 688 0008 D0E0      		ldi r29,hi8(matrix)
 236:../../quantum/matrix.c ****     uint8_t count = 0;
 689               		.loc 1 236 0
 690 000a 10E0      		ldi r17,0
 691               	.LVL48:
 692               	.L44:
 693               	.LBB48:
 238:../../quantum/matrix.c ****         count += bitpop16(matrix[i]);
 694               		.loc 1 238 0 discriminator 2
 695 000c 8991      		ld r24,Y+
 696               	.LVL49:
 697 000e 90E0      		ldi r25,0
 698 0010 0E94 0000 		call bitpop16
 699               	.LVL50:
 700 0014 180F      		add r17,r24
 701               	.LVL51:
 237:../../quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 702               		.loc 1 237 0 discriminator 2
 703 0016 80E0      		ldi r24,hi8(matrix+5)
 704 0018 C030      		cpi r28,lo8(matrix+5)
 705 001a D807      		cpc r29,r24
 706 001c 01F4      		brne .L44
 707               	.LBE48:
 241:../../quantum/matrix.c **** }
 708               		.loc 1 241 0
 709 001e 812F      		mov r24,r17
 710               	/* epilogue start */
 711 0020 DF91      		pop r29
 712 0022 CF91      		pop r28
 713               	.LVL52:
 714 0024 1F91      		pop r17
 715               	.LVL53:
 716 0026 0895      		ret
 717               		.cfi_endproc
 718               	.LFE20:
 720               		.section	.bss.matrix_debouncing,"aw",@nobits
 723               	matrix_debouncing:
 724 0000 0000 0000 		.zero	5
 724      00
 725               		.section	.bss.matrix,"aw",@nobits
 728               	matrix:
 729 0000 0000 0000 		.zero	5
 729      00
 730               		.section	.rodata.col_pins,"a",@progbits
 733               	col_pins:
 734 0000 33        		.byte	51
 735 0001 32        		.byte	50
 736 0002 31        		.byte	49
 737 0003 30        		.byte	48
 738               		.section	.rodata.row_pins,"a",@progbits
 741               	row_pins:
 742 0000 F0        		.byte	-16
 743 0001 F1        		.byte	-15
 744 0002 F4        		.byte	-12
 745 0003 F5        		.byte	-11
 746 0004 F6        		.byte	-10
 747               		.section	.data.debouncing,"aw",@progbits
 750               	debouncing:
 751 0000 05        		.byte	5
 752               		.text
 753               	.Letext0:
 754               		.file 3 "/usr/lib/avr/include/stdint.h"
 755               		.file 4 "../../tmk_core/common/matrix.h"
 756               		.file 5 "../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccx8DkhK.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccx8DkhK.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccx8DkhK.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccx8DkhK.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccx8DkhK.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccx8DkhK.s:12     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccx8DkhK.s:741    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccx8DkhK.s:81     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccx8DkhK.s:96     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccx8DkhK.s:113    .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccx8DkhK.s:130    .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccx8DkhK.s:145    .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccx8DkhK.s:162    .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccx8DkhK.s:179    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccx8DkhK.s:196    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccx8DkhK.s:213    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccx8DkhK.s:733    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccx8DkhK.s:728    .bss.matrix:0000000000000000 matrix
     /tmp/ccx8DkhK.s:723    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccx8DkhK.s:312    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccx8DkhK.s:750    .data.debouncing:0000000000000000 debouncing
     /tmp/ccx8DkhK.s:568    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccx8DkhK.s:590    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccx8DkhK.s:625    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccx8DkhK.s:649    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccx8DkhK.s:665    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
bitpop16
__do_copy_data
__do_clear_bss
